
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Cipher Game</title>
    <style>
    /* General styles */
body {
    background-color: #0d1117;
    color: #e6edf3;
    font-family: 'Poppins', sans-serif;
    text-align: center;
}

/* Main title */
h1 {
    font-size: 32px;
    font-weight: bold;
    color: #58a6ff;
    margin-bottom: 15px;
}

/* Cipher Instructions Container */
.cipher-instructions {
    background: #161b22;
    padding: 30px;
    border-radius: 12px;
    max-width: 650px;
    margin: 50px auto;
    box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.3);
    border: 2px solid #58a6ff;
}

/* Cipher Key Section */
.cipher-key-container {
    background: #0d1117;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    text-align: center;
}

/* Cipher Key Titles */
.cipher-key-title {
    font-size: 20px;
    font-weight: bold;
    color: #e6edf3;
    margin-bottom: 10px;
}

/* Ciphertext & Plaintext Boxes */
.cipher-box {
    background: #21262d;
    border: 2px solid #58a6ff;
    color: #e6edf3;
    font-size: 18px;
    padding: 12px;
    border-radius: 8px;
    width: 95%;
    margin: 8px auto;
    display: block;
    text-align: center;
}

/* Task Section */
.task-section {
    background: #21262d;
    padding: 15px;
    border-radius: 8px;
    border: 2px solid #58a6ff;
    color: #e6edf3;
    font-size: 16px;
    max-width: 95%;
    margin: 20px auto;
    text-align: left;
}

/* Task Title */
.task-title {
    font-weight: bold;
    font-size: 18px;
    color: #58a6ff;
    margin-bottom: 10px;
}

/* Task List */
.task-list {
    text-align: left;
    padding-left: 15px;
    font-size: 16px;
    line-height: 1.6;
}

/* Begin Challenge Button */
.begin-challenge-btn {
    background: #1f6feb;
    color: white;
    font-size: 18px;
    font-weight: bold;
    padding: 12px 20px;
    border-radius: 8px;
    cursor: pointer;
    display: block;
    margin: 25px auto;
    transition: all 0.2s ease-in-out;
    border: none;
    width: 90%;
}

.begin-challenge-btn:hover {
    background: #2a7de1;
    transform: scale(1.05);
}


/* Cipher Game Container */
.cipher-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin: 20px auto;
    max-width: 80%;
}

/* Cipher Text Letters */
.cipher-letter {
    background-color: #161b22;
    border: 2px solid #58a6ff;
    color: #e6edf3;
    font-size: 22px;
    width: 50px;
    height: 50px;
    text-align: center;
    line-height: 50px;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.error {
    background-color: #da3633 !important;
    border-color: #ff7b72 !important;
}

/* Buttons Styling */
button {
    font-size: 18px;
    font-weight: bold;
    padding: 12px 24px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

/* Yes and No Buttons */
.yes-btn, .no-btn {
    background: #30363d;
    color: white;
    margin: 10px;
    min-width: 100px;
}

.yes-btn:hover {
    background: #238636;
}

.yes-btn.selected {
    background: #238636;
}

.no-btn:hover {
    background: #da3633;
}

.no-btn.selected {
    background: #da3633;
}

/* Continue Button */
.continue-btn {
    background: #1f6feb;
    color: white;
    margin-top: 15px;
    padding: 12px 24px;
    font-size: 18px;
    border-radius: 8px;
    cursor: pointer;
    display: block;
    margin: 15px auto;
}

.continue-btn:hover {
    background: #2ea043;
}

/* Show Cipher Rules Button */
.show-rules-btn {
    background: #58a6ff;
    color: white;
    padding: 10px 20px;
    font-size: 16px;
    border-radius: 8px;
    margin-top: 15px;
    cursor: pointer;
}

/* Cipher Rules Modal */
.cipher-rules-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #161b22;
    border: 2px solid #58a6ff;
    padding: 20px;
    border-radius: 10px;
    width: 350px;
    max-height: 80vh;
    overflow-y: auto;
    text-align: center;
    z-index: 9999;
}

.cipher-rules-title {
    font-size: 22px;
    font-weight: bold;
    color: white;
    margin-bottom: 10px;
}

.cipher-mapping {
    font-size: 18px;
    color: white;
    text-align: left;
    margin: 10px;
    max-height: 60vh;
    overflow-y: auto;
}

/* Close Button in Cipher Rules */
.close-rules-btn {
    background: #da3633;
    color: white;
    padding: 8px 16px;
    border-radius: 6px;
    margin-top: 10px;
    cursor: pointer;
    display: block;
    width: 100%;
    font-size: 16px;
}

.summary-screen {
    text-align: center;
    margin-top: 50px;
}

.summary-title {
    font-size: 32px;
    font-weight: bold;
    color: white;
}

.summary-box {
    background-color: #161b22;
    color: #e6edf3;
    padding: 20px;
    margin: 20px auto;
    border-radius: 8px;
    border: 2px solid #58a6ff;
    width: 50%;
    font-size: 18px;
}

.retry-btn {
    background-color: #1f6feb;
    color: white;
    font-size: 18px;
    font-weight: bold;
    padding: 12px 24px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    margin-top: 20px;
}

.retry-btn:hover {
    background-color: #3c82f6;
}

/* Keep your base .cipher-letter style */
.cipher-letter {
    background-color: #161b22;      /* Dark background for each letter box */
    border: 2px solid #58a6ff;      /* Blue-ish border by default */
    color: #e6edf3;                 /* Light text color */
    font-size: 22px;
    width: 50px;
    height: 50px;
    line-height: 50px;
    text-align: center;
    border-radius: 8px;
    cursor: pointer;
    margin: 4px;                    /* Space between letters */
    transition: all 0.2s ease-in-out;
  }
  
  /* For Grammarly suggestions, only change the border and (optionally) add a glow */
  .grammarly-suggested {
    border-color: #7ee787;  /* bright green border */
    box-shadow: 0 0 6px #7ee787; /* optional glow around the border */
  }

  .grammarly-note {
    color: #7ee787;              /* Bright green text color */
    border: 2px solid #7ee787;   /* Same bright green border */
    background-color: #161b22;   /* Match your existing background or set to transparent */
    padding: 8px 12px;           /* Spacing around the text */
    border-radius: 8px;          /* Rounds the corners */
    display: inline-block;       /* So the border wraps neatly around the text */
    margin: 10px auto;           /* Center it with some spacing above/below */
    font-weight: bold;           /* Make the text stand out */
  }

    </style>
</head>
<body>
    <div id="root">Loading...</div>
    
<script>
const mockFetch = (url) => {
    if (url.endsWith("data.json")) {
        return Promise.resolve({
            json: () => Promise.resolve({
    "practice": [
      "a.",
      "b."
    ],
    "gameRounds": [
      "The first official round starts now.",
      "Let's see how well you decode this message.",
      "This is another challenge for you."
    ],
    "grammarlyRounds": {
      "systematicIndices": [2, 5, 8],
      "accuracyRate": 0.75,
      "rounds": [
        "A gentle stream flows through the peaceful meadow.",
        "Autumn leaves fall gracefully in the park."
      ]
    }
  }
  )
        });
    }
    return Promise.reject("Unknown fetch target");
};
window.fetch = mockFetch;
</script>

    <script type="module">
    import React, { useState, useEffect } from "react";
import "./CipherGame.css";
import seedrandom from "seedrandom";

// Fixed cipher rule remains unchanged.
const fixedCipherRule = {
  a: "m", b: "n", c: "b", d: "v", e: "c", f: "x", g: "z", h: "l", i: "k", j: "j",
  k: "h", l: "g", m: "f", n: "d", o: "s", p: "a", q: "p", r: "o", s: "i", t: "u",
  u: "y", v: "t", w: "r", x: "e", y: "w", z: "q"
};
// Global systematic indices for all grammarly rounds (if provided in data)
let globalGrammarlySystematicIndices = null; // ‚Üê (added global variable)
// Global accuracy rate for all grammarly rounds (if provided in data)
let globalGrammarlyAccuracyRate = null; // ‚Üê (new global variable for accuracy rate)

const shuffleArray = (array, rng) => {
  const result = [...array];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
};

const cipherCache = {};

const calculateEvaluationMetrics = (answers) => {
  let TP = 0, FP = 0, FN = 0;

  answers.forEach(({ userThinksCorrect, incorrectIndices, actualIncorrectIndices }) => {
    if (userThinksCorrect) {
      FN += actualIncorrectIndices.length;
    } else {
      const userSet = new Set(incorrectIndices);
      const actualSet = new Set(actualIncorrectIndices);

      for (let i of incorrectIndices) {
        if (actualSet.has(i)) TP++;
        else FP++;
      }

      for (let i of actualIncorrectIndices) {
        if (!userSet.has(i)) FN++;
      }
    }
  });

  const precision = TP + FP === 0 ? 0 : TP / (TP + FP);
  const recall = TP + FN === 0 ? 0 : TP / (TP + FN);

  return {
    TP,
    FP,
    FN,
    precision: precision.toFixed(2),
    recall: recall.toFixed(2),
  };
};

const CipherGame = () => {
  const [data, setData] = useState(null);
  const [round, setRound] = useState(0);
  const [cipherText, setCipherText] = useState("");
  const [userThinksCorrect, setUserThinksCorrect] = useState(false);
  const [userThinksCorrectExplicitlySet, setUserThinksCorrectExplicitlySet] = useState(false);
  const [incorrectIndices, setIncorrectIndices] = useState([]);
  const [continueVisible, setContinueVisible] = useState(false);
  const [yesSelected, setYesSelected] = useState(false);
  const [noSelected, setNoSelected] = useState(false);
  const [isCurrentCipherCorrect, setIsCurrentCipherCorrect] = useState(false);
  const [showRules, setShowRules] = useState(false);
  const [roundType, setRoundType] = useState("practice"); // "practice", "game", or "grammarly"
  const [showInstructions, setShowInstructions] = useState(true);
  const [practiceAnswers, setPracticeAnswers] = useState([]);
  const [showPracticeIncomplete, setShowPracticeIncomplete] = useState(false);
  const [showCompletionScreen, setShowCompletionScreen] = useState(false);
  const [showRoundSummary, setShowRoundSummary] = useState(false);
  const [evaluationMetrics, setEvaluationMetrics] = useState({
    practice: null,
    game: null,
    grammarly: null,
  });
  const [actualIncorrectIndices, setActualIncorrectIndices] = useState([]);
  const [interactionLog, setInteractionLog] = useState([]);
  const [roundStartTime, setRoundStartTime] = useState(Date.now());

  useEffect(() => {
    // Fetching data from /data.json
    fetch("/data.json")
      .then((response) => response.json())
      .then((jsonData) => {
        // If grammarlyRounds is an object (with systematicIndices, accuracyRate and rounds), then set the global values
        if (
          jsonData.grammarlyRounds &&
          typeof jsonData.grammarlyRounds === "object" &&
          jsonData.grammarlyRounds.systematicIndices &&
          jsonData.grammarlyRounds.rounds
        ) {
          globalGrammarlySystematicIndices = jsonData.grammarlyRounds.systematicIndices; // Set global systematic indices
          // Set global accuracy rate if provided; otherwise, it will remain null
          if (jsonData.grammarlyRounds.accuracyRate !== undefined) {
            globalGrammarlyAccuracyRate = jsonData.grammarlyRounds.accuracyRate;
          }
          jsonData.grammarlyRounds = jsonData.grammarlyRounds.rounds; // use rounds array from the object
        }
        setData(jsonData);
        generateCipher(jsonData.practice[0]);
      })
      .catch((error) => console.error("Error loading JSON:", error));
  }, []);

  const generateCipher = (reference, previousAnswer = null) => {
    if (!reference) {
      console.error("generateCipher received an undefined reference!");
      return;
    }

    // If reference is an object, extract its text; otherwise, use it directly.
    const refText = typeof reference === "string" ? reference : reference.text;
    const rng = seedrandom(refText); // deterministic based on the reference text

    let encrypted, baseIncorrectIndices, chars, eligibleIndices;
    if (cipherCache[refText]) {
      encrypted = cipherCache[refText].encrypted;
      baseIncorrectIndices = cipherCache[refText].incorrectIndices;
      setCipherText(encrypted);
    } else {
      chars = refText.split("");
      eligibleIndices = chars.map((_, i) => i).filter((i) => /[a-zA-Z]/.test(chars[i]));
      const numToEncodeCorrectly = Math.floor(eligibleIndices.length / 2);
      const shuffledIndices = [...eligibleIndices].sort(() => rng() - 0.5);
      const correctIndicesSet = new Set(shuffledIndices.slice(0, numToEncodeCorrectly));
      baseIncorrectIndices = eligibleIndices.filter((i) => !correctIndicesSet.has(i));

      encrypted = chars
        .map((char, index) => {
          const lower = char.toLowerCase();
          const isAlpha = /[a-zA-Z]/.test(char);
          if (!isAlpha) return char;
          if (correctIndicesSet.has(index)) {
            return fixedCipherRule[lower] || char;
          } else {
            let randomChar;
            do {
              randomChar = String.fromCharCode(97 + Math.floor(rng() * 26));
            } while (randomChar === fixedCipherRule[lower] || randomChar === lower);
            return randomChar;
          }
        })
        .join("");

      cipherCache[refText] = {
        encrypted,
        incorrectIndices: baseIncorrectIndices,
      };
      setCipherText(encrypted);
    }

    // For all rounds, the cipher text generation is the same.
    // If it's a grammarly round, adjust the highlighted indices (actualIncorrectIndices)
    if (roundType === "grammarly") {
      if (!eligibleIndices) {
        // If eligibleIndices wasn't computed in the cached branch, compute it now
        chars = refText.split("");
        eligibleIndices = chars.map((_, i) => i).filter((i) => /[a-zA-Z]/.test(chars[i]));
      }
      // Use the global accuracy rate if provided, otherwise use a fallback default (0.5)
      const accuracyRate = globalGrammarlyAccuracyRate !== null ? globalGrammarlyAccuracyRate : 0.5;
      const totalHighlights = baseIncorrectIndices.length;
      const trueCount = Math.floor(totalHighlights * accuracyRate);
      const falseCount = totalHighlights - trueCount;
      const trueSuggestions = shuffleArray([...baseIncorrectIndices], rng).slice(0, trueCount);
      const falseCandidates = eligibleIndices.filter((i) => !baseIncorrectIndices.includes(i));
      const falseSuggestions = shuffleArray([...falseCandidates], rng).slice(0, falseCount);
      const suggestedIndices = [...trueSuggestions, ...falseSuggestions].sort((a, b) => a - b);

      // Additional rule: Use global systematic indices if they exist for all grammarly rounds.
      let additionalIndices = [];
      if (globalGrammarlySystematicIndices && Array.isArray(globalGrammarlySystematicIndices)) {
        additionalIndices = globalGrammarlySystematicIndices;
      } else {
        // Fallback to default rule: always highlight incorrectly ciphered occurrences of "e"
        const configuredLetter = "e"; // Change this value to highlight a different letter.
        for (let i = 0; i < refText.length; i++) {
          if (refText[i].toLowerCase() === configuredLetter.toLowerCase()) {
            const expected = fixedCipherRule[refText[i].toLowerCase()] || refText[i];
            if (encrypted[i] !== expected && !suggestedIndices.includes(i)) {
              additionalIndices.push(i);
            }
          }
        }
      }
      const finalSuggestedIndices = [
        ...new Set([...suggestedIndices, ...additionalIndices]),
      ].sort((a, b) => a - b);
      setActualIncorrectIndices(finalSuggestedIndices);
    } else {
      setActualIncorrectIndices(baseIncorrectIndices);
    }

    if (previousAnswer) {
      setUserThinksCorrect(previousAnswer.userThinksCorrect);
      setUserThinksCorrectExplicitlySet(true);
      setIncorrectIndices(previousAnswer.incorrectIndices || []);
      setContinueVisible(true);
      setYesSelected(previousAnswer.userThinksCorrect);
      setNoSelected(!previousAnswer.userThinksCorrect);
    } else {
      setUserThinksCorrect(false);
      setUserThinksCorrectExplicitlySet(false);
      setIncorrectIndices([]);
      setContinueVisible(false);
      setYesSelected(false);
      setNoSelected(false);
    }

    setIsCurrentCipherCorrect(false);
    setRoundStartTime(Date.now());
  };

  const handleLetterClick = (index) => {
    if (!userThinksCorrectExplicitlySet || userThinksCorrect) return;
    setIncorrectIndices((prev) =>
      prev.includes(index) ? prev.filter((i) => i !== index) : [...prev, index]
    );
    setContinueVisible(true);
  };

  const handleYesClick = () => {
    setUserThinksCorrect(true);
    setUserThinksCorrectExplicitlySet(true);
    setNoSelected(false);
    setYesSelected(true);
    setIncorrectIndices([]);
    setContinueVisible(true);
  };

  const handleNoClick = () => {
    setUserThinksCorrect(false);
    setUserThinksCorrectExplicitlySet(true);
    setYesSelected(false);
    setNoSelected(true);
    setContinueVisible(false);
  };

  const handleContinue = () => {
    if (!data) return;

    const sortedUser = [...incorrectIndices].sort((a, b) => a - b);
    const sortedActual = [...actualIncorrectIndices].sort((a, b) => a - b);
    const arraysEqual =
      sortedUser.length === sortedActual.length &&
      sortedUser.every((value, index) => value === sortedActual[index]);

    const isAnswerCorrect = !userThinksCorrect && arraysEqual;

    const updatedAnswers = [...practiceAnswers];
    updatedAnswers[round] = {
      isCorrect: isAnswerCorrect,
      userThinksCorrect: userThinksCorrect,
      incorrectIndices: [...incorrectIndices],
      plainText:
        roundType === "practice"
          ? data.practice[round]
          : roundType === "game"
          ? data.gameRounds[round]
          : data.grammarlyRounds[round],
      cipherText: cipherText,
      actualIncorrectIndices: [...actualIncorrectIndices],
    };
    setPracticeAnswers(updatedAnswers);
    const logEntry = {
      roundType,
      roundIndex: round,
      timestamp: Date.now(),
      timeTaken: Date.now() - roundStartTime,
      referenceText: updatedAnswers[round].plainText,
      cipherText: updatedAnswers[round].cipherText,
      userThinksCorrect,
      incorrectIndices: [...incorrectIndices],
      actualIncorrectIndices: [...actualIncorrectIndices],
      isCorrect: isAnswerCorrect,
    };
    setInteractionLog(prev => [...prev, logEntry]);

    if (roundType === "practice") {
      if (round < data.practice.length - 1) {
        // Proceed to the next practice round regardless of correctness
        setRound(round + 1);
        generateCipher(data.practice[round + 1], updatedAnswers[round + 1]);
      } else {
        // Final practice round: check if all answers are correct.
        const allCorrect = updatedAnswers.every((answer) => answer?.isCorrect);
        if (allCorrect) {
          setRoundType("game");
          setEvaluationMetrics(prev => ({ ...prev, practice: calculateEvaluationMetrics(updatedAnswers) }));
          setShowRoundSummary(true);
          setRound(0);
          generateCipher(data.gameRounds[0]);
        } else {
          setShowPracticeIncomplete(true);
        }
      }
      } else if (roundType === "game") {
      if (round < data.gameRounds.length - 1) {
        setRound(round + 1);
        generateCipher(data.gameRounds[round + 1]);
      } else {
        setRoundType("grammarly");
        setEvaluationMetrics(prev => ({ ...prev, game: calculateEvaluationMetrics(updatedAnswers) }));
        setShowRoundSummary(true);
        setRound(0);
        generateCipher(data.grammarlyRounds[0]);
      }
    } else if (roundType === "grammarly") {
      if (round < data.grammarlyRounds.length - 1) {
        setRound(round + 1);
        generateCipher(data.grammarlyRounds[round + 1]);
      } else {
        setShowCompletionScreen(true);
        setEvaluationMetrics(prev => ({ ...prev, grammarly: calculateEvaluationMetrics(updatedAnswers) }));
        setShowRoundSummary(true);
      }
    }
  };

  if (!data) {
    return <p>Loading...</p>;
  }

  if (showRoundSummary) {
    const currentPhase = roundType === "game" ? "practice" : roundType === "grammarly" ? "game" : "grammarly";
    return (
      <div className="completion-screen">
        <h1 className="completion-title">{currentPhase.charAt(0).toUpperCase() + currentPhase.slice(1)} Round Summary</h1>
        {evaluationMetrics[currentPhase] && (
          <div className="metrics-box">
            <p>‚úÖ True Positives: {evaluationMetrics[currentPhase].TP}</p>
            <p>‚ö†Ô∏è False Positives (already correct): {evaluationMetrics[currentPhase].FP}</p>
            <p>‚ùå False Negatives (missed errors): {evaluationMetrics[currentPhase].FN}</p>
            <p>üéØ Precision: {evaluationMetrics[currentPhase].precision}</p>
            <p>üìà Recall: {evaluationMetrics[currentPhase].recall}</p>
          </div>
        )}
        <button
          className="continue-btn"
          onClick={() => {
            setShowRoundSummary(false);
            if (roundType === "game") {
              setRound(0);
              generateCipher(data.gameRounds[0]);
            } else if (roundType === "grammarly") {
              setRound(0);
              generateCipher(data.grammarlyRounds[0]);
            }
          }}
        >
          {roundType === "grammarly" ? "Continue to Summary Page" : `Continue to ${roundType.charAt(0).toUpperCase() + roundType.slice(1)} Round`}
        </button>
      </div>
    );
  }
  if (showCompletionScreen) {
    return (
      <div className="completion-screen">
        <h1 className="completion-title">üéâ Congratulations! üéâ</h1>
        <p className="completion-message">
          You have successfully completed all the practice and game rounds.
        </p>
    {["practice", "game", "grammarly"].map((type) =>
          evaluationMetrics[type] && (
            <div key={type} className="metrics-box">
              <h3>{type.charAt(0).toUpperCase() + type.slice(1)} Round Metrics</h3>
              <p>‚úÖ True Positives: {evaluationMetrics[type].TP}</p>
              <p>‚ö†Ô∏è False Positives (already correct): {evaluationMetrics[type].FP}</p>
              <p>‚ùå False Negatives (missed errors): {evaluationMetrics[type].FN}</p>
              <p>üéØ Precision: {evaluationMetrics[type].precision}</p>
              <p>üìà Recall: {evaluationMetrics[type].recall}</p>
            </div>
          )
        )}
        <button
          className="download-btn"
          onClick={() => {
            const blob = new Blob([JSON.stringify(interactionLog, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "cipher_game_logs.json";
            link.click();
          }}
        >
          üìÅ Download Game Log
        </button>
        <button
          className="restart-btn"
          onClick={() => {
            setShowCompletionScreen(false);
            setRoundType("practice");
            setRound(0);
            setPracticeAnswers([]);
            generateCipher(data.practice[0]);
          }}
        >
          Play Again
        </button>
      </div>
    );
  }

  if (showInstructions) {
    return (
      <div className="instructions-screen">
        <h1 className="title">Cipher Instructions</h1>
        <div className="cipher-key-container">
          <h2 className="cipher-key-title">Cipher Key</h2>
          <p className="cipher-label">Plaintext Alphabet</p>
          <div className="cipher-box">
            <p>abcdefghijklmnopqrstuvwxyz</p>
          </div>
          <p className="cipher-label">Ciphertext Alphabet</p>
          <div className="cipher-box">
            <p>
              {"abcdefghijklmnopqrstuvwxyz"
                .split("")
                .map((char) => fixedCipherRule[char])
                .join("")}
            </p>
          </div>
        </div>
        <p className="instructions-text">
          This is the cipher for this task. Sentences and words will be encoded using these rules.
          For each sentence, exactly 50% of the letters will be correctly ciphered according to the above rule,
          and 50% will be incorrect. Your task is to identify the letters that are incorrectly ciphered or
          confirm if you believe the cipher is entirely correct.
        </p>
        <h3 className="task-title">Your Task:</h3>
        <ul className="task-list">
          <li>First select whether the example is correct or incorrect.</li>
          <li>
            After that, select where in the text there are letters out of place or use the text box to describe the error.
          </li>
        </ul>
        <button className="start-button" onClick={() => setShowInstructions(false)}>
          Begin Challenge
        </button>
      </div>
    );
  }

  if (showPracticeIncomplete) {
    return (
      <div className="summary-screen">
        <h1 className="summary-title">Practice Round Incomplete</h1>
        <p className="summary-box">You did not answer all the practice questions correctly</p>
        <button
          className="retry-btn"
          onClick={() => {
            setRound(0);
            setShowPracticeIncomplete(false);
            if (practiceAnswers[0]) {
              generateCipher(practiceAnswers[0].plainText, practiceAnswers[0]);
            }
          }}
        >
          Try Again
        </button>
      </div>
    );
  }

  return (
    <div className="cipher-game">
      <h1 className="title">
        {roundType === "practice"
          ? "Practice Task"
          : roundType === "game"
          ? "Game Round"
          : "Grammarly Round"}{" "}
        {round + 1}
      </h1>
      <p className="reference-text">
        <strong>Reference Text:</strong>{" "}
        {roundType === "practice"
          ? data.practice[round]
          : roundType === "game"
          ? data.gameRounds[round]
          : data.grammarlyRounds[round]}
      </p>

      {roundType === "grammarly" && (
        <p className="grammarly-note">
          Grammarly suggests that the highlighted letters may be incorrect
        </p>
      )}

      <h2 className="encoded-message-title">Encoded Message:</h2>
      <div className="cipher-container">
        {cipherText.split("").map((char, index) => {
          const isGrammarlySuggested =
            roundType === "grammarly" && actualIncorrectIndices.includes(index);
          const isUserMarkedError = incorrectIndices.includes(index);

          return (
            <span
              key={index}
              className={`cipher-letter ${isUserMarkedError ? "error" : ""} ${
                isGrammarlySuggested ? "grammarly-suggested" : ""
              }`}
              onClick={() => handleLetterClick(index)}
            >
              {char}
            </span>
          );
        })}
      </div>

      <h3 className="is-cipher-correct">Is this cipher correct?</h3>
      <div className="buttons">
        <button className={`yes-btn ${yesSelected ? "selected" : ""}`} onClick={handleYesClick}>
          Yes
        </button>
        <button className={`no-btn ${noSelected ? "selected" : ""}`} onClick={handleNoClick}>
          No
        </button>
      </div>

      {userThinksCorrectExplicitlySet && !userThinksCorrect && (
        <p className="guidance">üîé Click on the incorrect letters in the cipher above</p>
      )}

      {continueVisible && (
        <button className="continue-btn" onClick={handleContinue}>
          Continue
        </button>
      )}

      <button className="show-rules-btn" onClick={() => setShowRules(true)}>
        üìú Show Cipher Rules
      </button>

      {showRules && (
        <div className="cipher-rules-modal">
          <h2 className="cipher-rules-title">Cipher Key</h2>
          <div className="cipher-mapping">
            {Object.keys(fixedCipherRule).map((char) => (
              <p key={char}>
                {char} ‚Üí {fixedCipherRule[char]}
              </p>
            ))}
          </div>
          <button className="close-rules-btn" onClick={() => setShowRules(false)}>
            Close
          </button>
        </div>
      )}
    </div>
  );
};

export default CipherGame;
    </script>
</body>
</html>
